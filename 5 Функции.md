##### **Объявление функций**
def <имя функции> (<параметры>): - управляющий оператор
	 <строка документации, или docstring,> - содержит документацию для функции
	 return <операторы возврата> - определяют, какое значение вычисляет функция при вызове
Параметры задаются согласно их позиции или ключевому слову:
	 def funk(first, second, third):
	 funk(1, 2, 3)
	 funk(first=1, second=2, third=3) 
	 funk(1, third=3, second=2) 
Можно чтобы параметр **вызывался** только с использованием метода ключевого слова. Для этого достаточно поставить * слева от него в объявлении функции. Все параметры справа от звездочки могут быть вызваны только с помощью ключевых слов.
	`def funk(first, second, *, third):`
	funk(1, 2, third=3)
Параметр со **значением по умолчанию** def does_defaults(first, second, third=3):
Ограничение параметров только **позиционным присваиванием**, ставя их слева от косой черты (/) в объявлении функции.
	def does_positional(first, /, second, third):
Использование **подстановочных знаков** в объявлении функции, чтобы принимать неустановленное количество позиционных или ключевых аргументов. Подстановочные знаки" — это специальные конструкции `*` и `**`, которые используются в объявлении функции, чтобы принимать переменное количество аргументов.
	**Подстановочный знак `*args`** - собирает все переданные позиционные аргументы в кортеж args
	Подстановочный знак `**kwargs` - позволяет принять любое количество именованных (ключевых) аргументов
###### **использовать аргументы:**
**Позиционные аргументы** — когда порядок аргументов ясен и их немного.
**Ключевые аргументы** — когда порядок не важен, или функция принимает много параметров.
##### **Функции без параметров**
def название функции(): - объявление ф
   блок кода (pass - заглушка если ф ничего не делает)
название функции() - вызов ф
##### **Функции с параметрами**
def название функции(параметры): - объявление ф
   блок кода (pass - заглушка если ф ничего не делает)
название функции(аргументы) - вызов ф

**Аргумент** – это любая порция данных, которая передается в функцию, когда функция вызывается. **Параметр** – это переменная, которая получает аргумент, переданный в функцию.
##### **Функция с возвратом значения**
def название_функции(): 
   блок кода 
   return выражение(будет отправлено в ту часть программы, которая вызвала функцию)
возврат значения =  название функции(аргументы) - вызов ф
*после выполнения инструкции return функция прекращает свою работу.*
**объявление функции**
def get_middle_point(x1, y1, x2, y2):
    x = (x1 + x2)/ 2
    y = (y1 + y2)/ 2
    return x
**считываем данные**
x_1, y_1 = int(input()), int(input())
x_2, y_2 = int(input()), int(input())
**вызываем функцию**
x, y = get_middle_point(x_1, y_1, x_2, y_2)
print(x, y)
##### **Функция с возвратом нескольких значений**
**объявление функции**
def get_middle_point(x1, y1, x2, y2):
    x = (x1 + x2)/ 2
    y = (y1 + y2)/ 2
    return x, y
**считываем данные**
x_1, y_1 = int(input()), int(input())
x_2, y_2 = int(input()), int(input())
**вызываем функцию**
x, y = get_middle_point(x_1, y_1, x_2, y_2)
print(x, y)

**возможно при этом вывод поменяется**
   return x1, x2
else:
   return x2, x1
##### **Функция с возвратом None**
Специальное встроенное значение **None**, которое используется для указания, что значение отсутствует.
def divide(a, b):
    if b == 0:
        result = None
    else:
        result = a / b
    return result
res = divide(5,0)
if res is None:
    print('Деление на ноль невозможно.') - **получаем вместо ошибки**
else:
    print(res) 
##### **Локальные и глобальные переменные.**
###### **Локальными** называются переменные, объявленные внутри функции и доступные только ей самой. Программный код за пределами функции к ним доступа не имеет. Согласно теории все локальные переменные расположены между def и концом отступа (объявления функции)
###### **Глобальными** называются переменные, объявленные в основной программе и доступные как программе, так и всем ее функциям. Если глобальная переменная не объявляется с использованием ключевого слова **global** внутри функции, то внутри этой функции вы никак не сможете изменить значение этой глобальной переменной.

##### **Декораторы** 
**Декоратор** позволяет вам создавать функции, изменяющие другие функции. 
###### **Передача функции add_one() переменной my_func в качестве значения.**
**def add_one(n):**  - 1 объявление функции которая принимает один параметр `n`.
    **return n + 1**
**my_func = add_one** - 2 переменная my_func теперь указатель на функцию add_one. Теперь у есть два имени, с помощью которых можно вызвать одну и ту же функцию:
	**add_one(5)**    # вернёт 6
	**my_func(5**)    # тоже вернёт 6
print(my_func)  --><function add_one at 0x000001F4B7A...> Это говорит: переменная my_func указывает на функцию add_one по определённому адресу в памяти.
print(my_func(2)) --> 3 вызываеn функцию my_func (то же самое, что add_one), передавая аргумент 2.
###### **Вызов списка функций**
def add_one(n): 1 объявление ф add_one
    return n + 1
def add_two(n): 2 объявление ф add_two
    return n + 2
my_functions = `[add_one, add_two]` 3 составлен список функций и привязан к переменной
for my_func in my_functions: 4 вызов функций из спика в циклк
    print(my_func(1))
###### **Вложенная функция когда одну функция часть блока кода другой.** 
**def call_nested():** 1 - создаёт объект функции call_nested и сохраняется в памяти.
    **print('outer')**
	    **def nested():** 2/1 - создается вложенная функция, существующая только внутри       call_nested() в памяти nested в памяти, как объект (не запускает её, а просто сохраняет как "вещь").
	        **print('nested')** 
    **return nested** 2/2 - возвращается ссылка на вложенную функцию nested 
**my_func = call_nested()** 2 - call_nested() -> создаётся Функция nested создаётся и       
					присваивают ее результат переменной создаётся внутри неё функция nested(), но не вызывается
					возвращается как объект 
					3 - my_func -> сcылка на вложенную функцию nested сохраняется в переменную my_func
**my_func()** 4 - Так как my_func теперь указывает на функцию nested, фактически вызывается nested()
###### **Оборачивание одной функции другой, добавив функциональность до или после.**
def add_one(number): 1 - создаёт объект функции add_one и сохраняется в памяти.
    return number + 1 5 - возвращается значение 2
def wrapper(number): 2 - создаёт объект функции wrapper и сохраняется в памяти.
	retval = add_one(number) 4 - вызывается функция add_one, ей передается аргумент   ..........                                        number = 1
						6 - значение 2 присваивается retval
    return retval 7 - функция add_one возвращает 2
print(wrapper(1)) 3 - вызывается функция wrapper(1), ей передается аргумент number = 1
				8 - выводится результат = 2

###### **Использование функции в качестве параметра. Передать ее в качестве значения функции, у которой есть вложенное определение, обертывающее переданную функцию.**
def add_one(number): 1 - создаёт объект функции add_one
    return number + 1
def do_wrapping(some_func): 2 - создаёт объект функция-декоратор, которая принимает другую функцию и возвращает обёрнутую версию с дополнительными действиями "до" и "после
    def wrapper(number):
        retval = some_func(number)
        return retval
    return wrapper
my_func = do_wrapping(add_one)  3 вызов do_wrapping(add_one). объект функции add_one (без скобок!) передается функции do_wrapping как аргумент some_func.
print(my_func(1))  














