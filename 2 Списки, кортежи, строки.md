Общие операции с последовательностями. 
Списки и кортежи. 
Строки и строковые методы. 
Диапазоны.
Последовательность - это упорядоченная конечная коллекция.
#### **1. Общие операции с последовательностями.** 
##### **Проверка принадлежности.**
С помощью - операции in. Она возвращает значение True, если элемент имеется в последовательности и False — в противном случае.
	'first' in 'first', 'second', 'third' => true
##### **Индексирование**
Получение доступа к элементу в ней, используя его местоположение
	sp1[7] =>	's'
##### **Слайсинг**
 Создание новых последовательностей указывая в квадратных скобках  начальный и конечный индексные номера последовательности, разделив их двоеточием.
	sp1 = "Ignatius"
	sp1[2:5] => 'nat'
можно указать размер шага. Например, считать по три: name[2:5:3]
отрицательные индексные номера использовать для создания срезов , начинающих отсчет с конца последовательности - name[-3:] 'ius'
##### **Сбор информации**
**len:** возвращает длину
	sp1 = "Ignatius"
	print(len(sp1)) -> 8
**min** и **max** возвращает минимальные и максимальные элементы:
print(min(sp1)) -> I
print(max(sp1)) -> u
**count:** - возвращает сколько раз появляется элемент в последовательности.
print(sp1.count('a')) -> 1
**index:** - возвращает индекс элемента в последовательности.
print(sp1.index('s')) -> 7
**index** позволяет создать срез до элемента. 
print(sp1[:sp1.index('u')]) -> 'Ignati'
##### **Математические операции**
сложения с последовательностями одного типа.
**print("prefix" + "-" + "postfix")** -> 'prefix-postfix'
умножения с последовательностями одного типа.
p**rint("prefix" `*` 3)** -> 'prefixprefixprefix'
вычисление суммы всех элементов содержащих числовые значения в последовательности -  **sum**(tuple_1)
###### **Объединение последовательностей с помощью оператора +**
tuple_1 = tuple_1 + tuple_2 => (1, 2, 4) - создается новая последовательность из исходных tuple 
###### **Сравниваем кортежи с помощью операторов**  $==, <, >$
a = (7, 2)
b = (7, 2, 9)
print(a == b)   # False
print(a <= b)   # True
print(a > b)    # False
#### **3. Списки и кортежи**
Списки и кортежи — последовательности, которые могут содержать объекты любого
типа. Их содержимое может быть смешанным, поэтому в одном списке могут
быть строки, целые числа, экземпляры, числа с плавающей точкой и другие объекты. Разделители в списках и кортежах - запятые. Элементы в **списке** заключены
в **квадратные скобки**, а в **кортеже - в круглые**. Основное различие между списками
и кортежами в том, что первые изменяемы, а вторые - нет. Можно изменить содержимое списка, кортеж невозможно. 
numbers = [2, 4, 6, 8, 10] список
numbers = (2, 4, 6, 8, 10) кортеж
##### **Создание списков и кортежей**
###### **Создание списка**
sp1 = [] - пустой список можно создать с помощью []
sp1 = [2, 4, 6, 8, 10] - **перечислив его элементы** через запятую в квадратных скобках
с помощью **функции list()**
	sp1 = list() 
	sp1 = list('Python'))  Создается список ['P','y','t','h','o','n'] 
	sp1 = list(range(7)) => [0, 1, 2, 3, 4, 5, 6] 
из строки с помощью **метода split()** разбивает строку на слова или строки, используя в качестве разделителя указанный параметр (по умолчанию пробельный символ). 
	s = 'Каждый охотник желает'
	sp1 = s.split() => ['Каждый', 'охотник', 'желает''] - пробел по умолчанию
	sp1 = s.split(' ') => ['Каждый', 'охотник', 'желает']
	sp1 = s.split(' ,') => ['Каждый охотник желает] - нет разделителя
	s = '10 20 30 40 50' -> из строки цифр
	sp1 = s.split('  ') => ['10', '20', '30', '40', '50']
###### **Создание кортежа**
tuple_1 = () - пустой кортеж можно создать с помощью ()
(,) - выдаст ошибку
tuple_1 = (1,), tuple_2 = (1, 2, 3, 4, 5) - **перечислив его элементы** через запятую в круглых скобках
с помощью функции **tuple()** 
	из списка print(tuple([2, 4, 6, 8, 10])) -> (2, 4, 6, 8, 10) - кортеж из элементов списка
	из строки print(tuple('1234'))  -> ('1', '2', '3', '4') - кортеж из строк
##### **Добавление и удаление элементов списка**
###### **Добавление элементов списка **
методы append, insert, extend  - изменяют список. по итогу сначала добавляют элемент потом в следующей строке используют.
sp1 = ['a', 'b']
**sp1.append(('c','d'))** - print(sp1)  => ['a', 'b', ('c', 'd')] append списка добавляет  список в конец списка list1 как последний элемент не разбивая на элементы
**sp1.append(('cd'))** - print(sp1)  => ['a', 'b', 'cd'] append строки добавляет  строку в конец списка list1 как последний элемент
**sp1.insert(1,('c', 'd'))** - print(sp1)  => ['a', ('c', 'd'), 'b'] insert списка добавляет  список в список list1 как один элемент состоящий из списка на указанную позицию.  Если задан индекс за пределами конца списка, то значение будет добавлено в конец списка. Если применен отрицательный индекс, который указывает на недопустимую позицию, то значение будет вставлено в начало списка.
**sp1.insert(1,('cd'))** - print(sp1)  => ['a', 'cd', 'b'] insert строки добавляет  строку в список list1  на указанную позицию 
**sp1.extend(1,('c', 'd'))** - print(sp1)  => ['a', 'b', 'c', 'd'] extend списка добавляет  список в конец списка list1 
**sp1.extend(1,('cd'))** - print(sp1)  => ['a', 'b', 'c', 'd'] extend строки превращает ее в список из элементов строки и добавляет  полученный список в конец списка list1
###### **Удаление элементов списка **
sp1 = ['a', 'b']
**del sp1[1]** - print(sp1) => ['a'] удаляет элементы списка по определенному индексу (1)
**sp2 = sp1.pop(1)** - print(sp1) => ['a'] удаляет элементы списка по определенному индексу (1)
               - print(sp2) => b sp2 присваивается удаленный элемент списка в виде строки
               Если индекс не указан, то метод удаляет и возвращает последний элемент списка. Если список пуст или указан индекс за пределами диапазона, то во время выполнения происходит ошибка.
**sp1.remove('b')**  - print(sp1) => ['a'] ищет и удаляет первый найденный элемент списка по значению ('b') , а все остальные элементы списка сдвигаются. Если значение в списке не найдено, вызывается исключение ValueError. 
sp1.clear()  => [] возвращает пустой список
##### **Распаковка**
Распаковка списка или кортежа — это процесс, при котором Python «разбирает» содержимое списка (или кортежа) на отдельные значения и присваивает их переменным.
point = (3, 4)
x, y = point
print(x)  # 3
print(y)  # 4
**Распаковка с * (звёздочкой)**. Звёздочка * позволяет сохранить оставшиеся элементы в отдельный список. Она присоединит все элементы, не присвоенные другим переменным:
numbers = [1, 2, 3, 4, 5]
`a, *c, e = numbers`
print(a) =>1
print(c)  => [2, 3, 4]
print(e) => 5
**Распаковка в функциях.** Можно распаковать список или кортеж как аргументы функции:
def greet(name, age):
    print(f"Hello {name}, you are {age} years old.")
data = ("Alice", 30)
`greet(*data)`  # то же самое, что greet("Alice", 30)
**Объединение списков с распаковкой (`*`)**
sp1 = [1, 2]
sp2 = [3, 4]
`combined = [*sp1, *sp2]`
`print(combined)  # [1, 2, 3, 4]`
##### **Сортировка списков**
**sp1.sort()** сортирует по возрастанию
**sp1.reverse()** сортирует по убыванию.
**sp2 = sorted(sp1)** сортирует элементы списка sp1() по возрастанию и возвращает отсортированную копию списка.
##### **Основы работы 
**len(sp)** - выводит количество элементов списка (кортежа) sp
**2 in sp** - проверяет наличие элемента 2 в списке (кортеже) можно использовать not in
sp[n] - выводит n - 1 элемент списка sp
sp[-n] - выводит n  с конца элемент списка (кортежа)
sp[1:3] - получаем список (кортеж ) из элементов с 2 по 3
sp[1:] - получаем список (кортеж) из элементов с 2 по последний
sp[:3] - получаем список из элементов с 1 по 3
sp[-9:-4] - получаем список (кортеж)  с 9 до 5 значения от конца
sp = sp[::-1] - разворачиваем список создавая копию списка, ничего не меняя в текущем.
sp[0] = 2 - изменяет первый элемент списка на 2
sp[2:5] = [2, 3, 3] - изменяет элементы с 3 до 5
sp = sp1 + sp2 - получаем список (кортеж) состоящий из двух списков
sp = sp1 * 2 - получаем список (кортеж) состоящий из списка sp1 повторяющегося дважды
sp += sp1 - добавляем к списку sp список sp1
sp * = 5 - повторяем список sp 5 раз
sum(sp) - вычисляет сумму элементов списка (кортежа)
min(sp) принимает в качестве параметра список (кортеж) и находит значение минимальный элемент
max(sp) принимает в качестве параметра список (кортежа) и находит значение максимальный элемент
#### **3. Строки и строковые методы.** 
Строка - это неизменяемая последовательность символов в кавычках.
##### **Строковые литералы**
Строковый литерал может быть записан в одинарных, двойных или тройных кавычках
"'Hello, AI student!"'
"Hello, AI student!"
'Hello, AI student!'
##### **Кодировка символов**
Кодировка — это способ перевода символов (таких как буквы, знаки пунктуации, служебные знаки, пробелы и контрольные символы) в целые числа и затем непосредственно в биты. Каждый символ может быть закодирован уникальным двоичным кодом.
Функция **num1 = ord('A')** - позволяет определить код некоторого символа в таблице символов Unicode/
Функция **chr1 = chr(65)** - позволяет определить по коду символа сам символ.

##### **Специальные символы, каждому из которых предшествует обратный слеш.**
**`\\Обратный слэш (сам символ \)`** используется в строках, чтобы вставить сам символ обратного слэша (\). Это нужно потому, что в строковых литералах обратный слэш является началом управляющей последовательности, а двойной обратный слэш позволяет интерпретировать его буквально, как обычный символ. **print("`\\`") => \**
###### **`\'`	Одинарная кавычка (для использования внутри строки с одинарными кавычками).**   используется для вставки одинарной кавычки (') внутрь строки, которая сама ограничена одинарными кавычками. Это позволяет избежать ошибки, так как одинарная кавычка в строке может восприниматься как конец строки.
**text = 'Это строка с \'одинарной кавычкой\'.'**
###### **`\"`	Двойная кавычка (для использования внутри строки с двойными кавычками).**
###### **`\t`	Табуляция (горизонтальный отступ).** вставляет табуляцию (горизонтальный отступ) в строку. Это полезно для выравнивания текста в колонках или просто для создания отступов между словами. 
###### **`\n`	Перевод строки (новая строка).** перевод строки текста после \n на следующую строку.
**Префикс «r»**  "Сырые" строки - подавляют экранирование! Это значит, что обратная косая черта считается самостоятельным символом и выводится. (Весть текст выводится как есть)
raw_string = r'C:\file.txt'        => C:\file.txt
##### **Операторы строк**
оператор +
оператор *
оператор in - 'L' in str1 => True или False
##### **Индексация строк**
s[0] -  первый символ строки
s[-1] - последний символ строки
##### **Срезы строк**
###### **индексация с переду с 0, с конца с 1**
s`[x:y]` первое число – это то место, где начинается срез (**включительно**), а второе – это место, где заканчивается срез (не включительно**).
s[x:] срез до конца строки. 
s[:y] срез от начала строки.
s[-9:-4] срез с 9 до 5 значения от конца
s[1:7:2] срез из каждого второго символа
s`[::-1]` символы будут в обратном порядке
#### **Форматирование строк**
###### **конкатенация (склеиваем несколько строк с помощью операции сложения +)**
###### **форматирование строк с помощью оператора %** - % место куда вставляется значения (`%s` — это **формат для строки**. `%d` — это **формат для целого числа**.)
name = "Иван"
age = 25
city = "Москва"
formatted_string = "Меня зовут %s, мне %d лет, я живу в %s." % (name, age, city) => Меня зовут Иван, мне 25 лет, я живу в Москва.
аналог - используется словарь, и в строке подставляются значения, соответствующие ключам из словаря.
data = {"name": "Иван", "age": 25} formatted_string = "Меня зовут %(name)s, и мне %(age)d лет." % data => Меня зовут Иван, и мне 25 лет.
Список форматов:
%s — строка
%d — целое число (десятичное)
%f — число с плавающей точкой
%x — целое число в шестнадцатеричном формате
%.nf — число с плавающей точкой с точностью до n знаков после запятой
%o — число в восьмеричном формате
%e — число в экспоненциальной записи
##### **str.format()** 
Вставляет переменные и значения в заранее определённые места в строках, где стоят фигурные скобки {}
name = "Иван"
age = 25
formatted_string = "Меня зовут {} и мне {} лет.".format(name, age) => Меня зовут Иван и мне 25 лет.
###### **Позиционные аргументы**
formatted_string = "Меня зовут {0} и мне {1} лет. {0}, ты молодец!".format("Иван", 25) => Меня зовут Иван и мне 25 лет. Иван, ты молодец!
Здесь {0} и {1} — это индексы, которые обозначают позиции переданных аргументов в метод format().
###### **Именованные аргументы**
formatted_string = "Меня зовут {name} и мне {age} лет.".format(name="Иван", age=25) => Меня зовут Иван и мне 25 лет.
Здесь {name} и {age} — это плейсхолдеры, которые заменяются значениями, переданными с помощью именованных аргументов.

##### **f-строки**
###### **простое форматирование вывода f-строкой**
name = 'Fred'
f'He said his name is {name}.' => He said his name is Fred.
___________________________________________________________________________
###### **вложение f-строк друг в друга**
import decimal
width = 10 # указывает общую ширину вывода, включая символы, пробелы, точку и знаки.
precision = 4 # указывает количество знаков после десятичной точки.
value = decimal.Decimal("12.34567")
f'result: {value:{width}.{precision}}' => result:      12.35
_________________
first_name = 'Timur'
last_name = 'Guev'
print(f'Hello, {first_name} {last_name}') => Hello, Timur Guev
_______________________________________________________________________________
##### **методы строк**
###### **Конвертация регистра**
**s.capitalize()** - возвращает копию строки s, в которой первый символ имеет верхний регистр, а все остальные символы имеют нижний регистр (cимволы, не являющиеся буквами алфавита, остаются неизменными) a = "hello, world" **b = a.capitalize()** => Hello, world
**s.swapcase()** - возвращает копию строки `s`, в которой все символы, имеющие верхний регистр, преобразуются в символы нижнего регистра и наоборот.
**s.title()** - возвращает копию строки `s`, в которой первый символ каждого слова переводится в верхний регистр
**s.lower()** - возвращает копию строки s, в которой все символы имеют нижний регистр
**s.casefold()** - возвращает копию строки s, в которой все символы имеют нижний регистр, умеет преобразовывать специальные буквы других языков. 
**s.upper()** - возвращает копию строки s, в которой все символы имеют верхний регистр.
###### **Поиск и замена**
**s.count('sub', start, end)**  - считает количество непересекающихся  вхождений подстроки 'sub' в исходную строку s с позиции символа  start и продолжающейся вплоть до позиции символа  end, но не включающей ее.
**s.startswith('foo', start, end)**  -  определяет начинается ли исходная строка `s` подстрокой 'foo'. Возвращает **True** или **False**.
**s.endswith('bar', start, end)** - определяет оканчивается ли исходная строка `s` подстрокой 'bar'
**s.find('foo')** - находит индекс первого вхождения подстроки 'foo' в исходной строке 's'. Если строка s не содержит подстроки 'foo', то метод возвращает значение `-1`.
s.**rfind**('foo') - находит индекс первого вхождения подстроки 'foo' в исходной строке 's' начиная с конца. Если строка s не содержит подстроки 'foo', то метод возвращает значение -1.
**s.index('foo', start, end)** идентичен методу find('foo', start, end), за тем исключением, что он вызывает ошибку  'ValueError: substring not found' во время выполнения программы, если подстрока 'foo' не найдена.
**s.rindex('foo', start, end)** идентичен методу s.index('foo', start, end), за тем исключением, что он ищет первое вхождение подстроки 'foo' начиная с конца строки 's'.
**s.strip()** - возвращает копию строки s у которой удалены все пробелы стоящие **в начале и конце** строки.
**s.lstrip()** - возвращает копию строки `s` у которой удалены все пробелы стоящие **в начале** строки.
**s.rstrip()** - возвращает копию строки `s` у которой удалены все пробелы стоящие **в конце** строки.
**s.replace('foo', 'grault')** - возвращает копию s **со всеми** вхождениями подстроки **foo**, замененными на **grault**. (**s.replace(' ', '')** - удалит все пробелы в строке
**s.replace('foo', 'grault', 2)** - возвращает копию `s` **с первыми двумя** вхождениями подстроки **foo**, замененными на **grault**.
###### Классификация символов
s.**isalnum**() - определяет, состоит ли исходная строка s из буквенно-цифровых символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенно-цифровых символов и `False` в противном случае.
s.**isalpha**() - определяет, состоит ли исходная строка s из буквенных символов, возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенных символов и `False` в противном случае.
**s.isdigit()** - определяет, состоит ли исходная строка s **только** из цифровых символов, возвращает значение `True` если исходная строка является непустой и состоит **только** из цифровых символов и `False` в противном случае.
**s.islower()** - определяет, являются ли **все** буквенные символы исходной строки s строчными, возвращает значение `True` если все буквенные cимволы исходной строки являются строчными и `False` в противном случае. **Все неалфавитные символы игнорируются!**
**s.isupper()** - определяет, являются ли **все** буквенные символы исходной строки заглавными, возвращает значение `True` если все буквенные символы исходной строки являются заглавными и `False` в противном случае. **Все неалфавитные символы игнорируются!**
s.**isspace**() - определяет, состоит ли исходная строка **только** из пробельных символов, возвращает значение `True` если строка состоит только из пробельных символов и `False` в противном случае.
###### **Соединение строк**
str2=" ".join(str1) объединяет строки в одну строку, вставляя между ними определенный разделитель(в данном случае пробел)
words = `["Let", "me", "speak", "from", "my", "heart", "in", "English"]` - подается **список строк**
sentence=" ".join(words)
print(sentence) => Let me speak from my heart in English

###### if s[i] in '1234567890' проверяем является ли символ цифрой
print(s.isdigit()) - проверяет состоит ли s только из цифр и возвращает True, если есть буквы возвращает False 
print(a.lower()) - перевод из заглавных в строчные
print(a.upper()) - перевод из строчных в заглавные
str = str * 3
print(* str) - выводит элементы строки через один символ пробела
print(* str, sep='\ n') - выводит элементы строки , каждый на отдельной строке