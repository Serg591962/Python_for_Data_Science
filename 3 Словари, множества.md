#### **1 Словари**
это объект, который хранит коллекцию данных. Каждый хранящийся в словаре элемент имеет две части: ключ и значение. На практике элементы словаря обычно называются парами **"ключ : значение"**.
##### **Создание словаря**
###### **с помощью {}**
countries = {'Египет': 'Каир', 'Тунис': 'Тунис', 'Ангола': 'Луанда'}
Значения в словаре могут быть объектами любого типа, но ключи должны быть неизменяемыми объектами. Например, ключами могут быть строковые значения, целые числа, значения с плавающей точкой или кортежи, но не могут быть списки. Ключи в словаре не должны повторяться – если добавить в словарь ключ, идентичный существующему, Python сохранит только один ключ с последним значением:
###### **с помощью функции dict() и передачи пары ключ/значение конструктору в виде списка**
country = dict(Egypt = 'Cairo', population = 106646200, language = 'Arabic')
###### **с помощью функции dict() и передачи пары ключ/значение конструктору в виде списка/кортежа списков/кортежей (возможен любой вариант из четырех)**
`subject_2 = dict([['name','Paula'],['height',64],['gpa',3.8]],['ranking',1])`
###### **с помощью zip() и dict() если имеются два списка, в одном из которых хранятся ключи, а в другом – значения,**
keys = ['Железный человек', 'Халк', 'Чёрная Вдова', 'Капитан Америка']
values = ['Тони Стар', 'Брюс Бэннер', 'Наталья Романов', 'Стив Роджерс']
Marvel = dict(zip(keys, values))
##### **Получение значения из словаря**
просто пишут выражение в формате: Marvel['Капитан Америка''] => 'Стив Роджерс'
Если ключ не существует, то вызывается исключение KeyError (ошибка ключа).
Если использовать специальную функцию словаря get(). Если ключ существует, то получаем связанное с ним значение, иначе - None или опциональное значение.
print(directors.get('Лукас', 'Нет сведений об этом режиссере')) => 'Нет сведений об этом режиссере'
##### **Добавление элементов в существующий словарь**
Используется выражение в формате: название словаря[ключ] = значение
Marvel['Железный человек'] = 'Тони Стар'
Если ключ уже в словаре существует, то присвоенное ему значение будет заменено новым значением. Если же ключ отсутствует, то он будет добавлен в словарь вместе со связанным с ним значением.
student_record = {'name':'Paula', 'height':64, 'gpa':3.8}
student_record['applied'] = '2019-10-31'
student_record{'name':'Paula', 'height':64, 'gpa':3.8, 'applied': '2019-10-31'}
**с помощью get** только если такого ключа нет **student['height'] = 170**
fantasy.get('Властелин колец', 0) => 'Джон Толкин'
fantasy[Властелин колец] = fantasy.get(Властелин колец, 0) + 1 => Если ключ уже в словаре существует, то к присвоенному ему значению будет добавлена 1. Если же ключ отсутствует, то он будет добавлен в словарь вместе с 0 к которому добавят 1.
##### **Получение всех ключей с помощью функции keys()** 
fantasy = {'Властелин колец': 'Джон Толкин', 'Игра престолов': 'Джордж Мартин', 'Дюна': 'Фрэнк Герберт'}
k = fantasy.keys()
print(k)  => dict_keys(['Властелин колец', 'Игра престолов', 'Дюна']) - возвращается объект типа `dict_keys()` - итерабельное представление ключей.
print(list(k)) => преобразовывает в список ['Властелин колец', 'Игра престолов', 'Дюна']
##### **Получение значения соответствующего ключу с помощью функции get()** 
Метод dict.get(key, default) возвращает значение, связанное с указанным ключом key, если этот ключ существует в словаре. Если ключа нет, возвращается значение по умолчанию, указанное в default.
fantasy.get('Властелин колец', 0) => 'Джон Толкин'
fantasy.get('Властелин', 0) => 0
##### **Получение всех значений с помощью функции values()** 
fantasy = {'Властелин колец': 'Джон Толкин', 'Игра престолов': 'Джордж Мартин', 'Дюна': 'Фрэнк Герберт'}
k = fantasy.values()
print(k)  => dict_values(['Джон Толкин', 'Джордж Мартин', 'Фрэнк Герберт'])
print(list(k)) => ['Джон Толкин', 'Джордж Мартин', 'Фрэнк Герберт']
result = list(fantasy.values()).count('Джон Толкин') => 1 возвращает сколько раз в словаре встречается значение 'Джон Толкин'

##### **Получение всех пар «ключ — значение» с помощью функции items()**
fantasy = {'Властелин колец': 'Джон Толкин', 'Игра престолов': 'Джордж Мартин', 'Дюна': 'Фрэнк Герберт'}
k = fantasy.items()
print(k) => dict_items([('Властелин колец', 'Джон Толкин'), ('Игра престолов', 'Джордж Мартин'), ('Дюна', 'Фрэнк Герберт')])
print(list(k)) => [('Властелин колец', 'Джон Толкин'), ('Игра престолов', 'Джордж Мартин'), ('Дюна', 'Фрэнк Герберт')]
##### **Удаление элементов списка**
###### **Удаление элементов по их ключу с помощью оператора del**
del fantasy ['Властелин колец']
###### **Получение значения элемента по ключу и удаление его с помощью функции pop()** 
fantasy = {'Властелин колец': 'Джон Толкин', 'Игра престолов': 'Джордж Мартин', 'Дюна': 'Фрэнк Герберт'}
k = fantasy.pop('Игра престолов')
print(fantasy) => {'Властелин колец': 'Джон Толкин', 'Дюна': 'Фрэнк Герберт'}
print(k) => Джордж Мартин
Если ключа нет выдаст ошибку или значение по умолчанию если оно предусматривалось k = fantasy.pop('Игра престолов', значение по умолчанию)
###### **Удаление всех элементов с помощью функции clear()**
Функция clear() удаляет все ключи и значения из словаря.
fantasy = {'Властелин колец': 'Джон Толкин', 'Игра престолов': 'Джордж Мартин', 'Дюна': 'Фрэнк Герберт'}
fantasy.clear()
print(fantasy) => {}
#### **Основные операции со словарями**
##### **Получение длины словаря**
print(len(fantasy)) =>  выведет количество пар
##### **Проверка наличия элемента в списке**
Оператор in позволяет определить, содержится ли в словаре определенный ключ.
fantasy = {'Властелин колец': 'Джон Толкин', 'Игра престолов': 'Джордж Мартин', 'Дюна': 'Фрэнк Герберт'}
print('Властелин колец' in fantasy) => True если нет Falche
##### **Сравнивание словарей**
Python сравнивает ключи и значения по одному. Порядок, в котором они создавались, не имеет значения.
Как и в случае со списками и кортежами,  словари можно сравнивать с помощью операторов == и !=, другие операторы со словарями не будут работать. Программа вызовет исключение: TypeError: '<=' not supported between instances of 'dict' and 'dict'
#### **Последовательный обход словаря**
##### **Перебор ключей**
С помощью  цикла for.
for elem in fantasy:
   print(elem) => все ключи
##### **Перебор значений с помощью values()**
for elem in fantasy.values():
   print(elem) => все значения ключей
##### **Перебор пар ключ-значение с помощью items()**
for elem in fantasy.items():
   print(elem) => ряд кортежей, полученных из словаря:

Присвоить значение кортежа другим переменным можно в один этап.
for kl, zn in fantasy.items():
	print(f'{kl} - {zn}') =>Властелин колец - Джон Толкин
					Игра престолов - Джордж Мартин
					Дюна - Фрэнк Герберт

#### **2 Множества**
**множество (set)** — cоставной тип данных, представляющий собой неупорядоченный набор уникальных объектов (элементов множества) под одним именем. Множества изменяемы и чаще всего используются для удаления дубликатов и всевозможных проверок на вхождение.
 Основные свойства множеств:
- Все элементы в множестве должны быть уникальными. Никакие два элемента не могут иметь одинаковое значение.
- Множества не упорядочены, т. е. элементы в множестве не хранятся в каком-то определенном порядке.
- Хранящиеся в множестве элементы могут иметь разные типы данных.
##### **Создание 
###### **с помощью оператора {}**  -  нужно в фигурных скобках перечислить его элементы
A = {5, 4, 55, 1, 2, 1, 45, 'hello', False,  4, -10} => {False, 1, 2, 4, 5, 45, 'hello', -10, 55}   - Элементы не упорядочены, и нет возможности отличить один элемент от другого. Поэтому множество содержит только уникальные элементы, что делает его удобным инструментом для удаления дубликатов и проверок на вхождение.
###### **с помощью функции set()** - 
empty_set = set() => {}пустое множество
my_set = set([1,2,3]) => {1, 2, 3}
my_set1 = set([1]) => {1}
letters = set('Hello') => {'l', 'e', 'o', 'H'} - каждый отдельный символ в строковом значении становится членом множества
##### **Проверка наличия элемента в множестве**
'l' in {'H', 'e', 'l', 'o'}
##### **Методы и функции множеств**
###### **Получение количества элементов с помощью len()**
n = len({'a', 'b', 'c', 'a'})
##### **Добавление в множество**
###### **Добавление элемента в множество с помощью add()**
myset.add(1)
###### **Добавление элементов в множество с помощью update()**
В качестве аргумента передается группа элементов -итерируемый объект, список, кортеж, строковое значение или другое множество. - myset.update(list2)
##### **Удаление из множества**
###### **С помощью функций remove()** 
students.remove('Karl') - удалить определенный элемент. Этот метод не возвращает удаленный элемент. Попытавшись удалить элемент, которого нет во множестве, вы получите ошибку:
###### **С помощью функций discard()** 
gas.discard('водород') - если указанный элемент в множестве не найден исключение KeyError не вызывается 
###### **С помощью функций pop()** 
В отличие от аналогичного списочных методов, для множеств метод pop() удаляет **случайный** элемент и возвращает его значение.
gas_1 = gas.pop()
###### **Удаляем все множество с помощью функций clear()**
junk_food.clear() => print(junk_food) --> set()
##### **Операции над множествами**
**Непересекающиеся множества - если у них нет общих элементов.**
even = set(range(0,10,2))  =>  even {0, 2, 4, 6, 8} 
odd = set(range(1,11,2)) =>  odd {1, 3, 5, 7, 9}  
even.isdisjoint(odd) => True -проверка на пересечение
**Подмножество** - если все элементы множества B можно найти в множестве A
nums = set(range(21)) => nums {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20} threes = set(range(3,21,3))=> threes {3, 6, 9, 12, 15, 18} 
threes.issubset(nums) => True проверка на подмножество
threes <= nums => True проверка, является ли множество слева подмножеством множества справа:
**Строгое подмножество** - все элементы первого множества есть во втором, но не все элементы второго есть в первом
threes < nums => True -->проверка на строгое подмножество.
**Надмножества и строгие надмножества** Надмножество обратно подмножеству: если в первом множестве есть все элементы второго, оно будет его надмножеством. И если одно множество служит надмножеством другого и они не равны, то оно будет строгим надмножеством. 
nums.issuperset(threes) =>True nums - надмножество
nums > threes - проверка на надмножество
True nums >= nums - проверка на строгое надмножество
**Объединение** - множество содержит элементы обоих множеств
odds.union(evens)
odds | evens
**Пересечение** -множество со всеми общими для обоих множеств элементами.
under_ten.intersection(odds) 
under_ten & odds
**Разность** - это все элементы первого множества, которых нет во втором
odds.difference(under_ten)
odds - under_ten
**Симметрическая разность** - это множество с элементами, находящимися либо в одном, 
ибо в другом множестве, но не в их пересечении.
under_ten.symmetric_difference(over_five)
under_ten ^ over_five
**Обновление множеств**
- unique_num.update( {3, 4, 5, 7} ) - обновление из другого множества
- unique_num.update( [8, 9, 10] ) - обновление из списка
- unique_num.difference_update( range(0,12,2) ) - обновить разницу из диапазона
- unique_num.intersection_update( { 2, 3, 4, 5 } ) - обновить пересечение:
- unique_num.symmetric_difference_update( {5, 6, 7 } ) - обновить симметрическую разность:
- unique_letters |= set("Arkansas") -  обновить оператор объединения
- unique_letters -= set('Arkansas') - обновить оператор разницы:
- unique_letters ^= set('mud') 2 unique_letters - обновить оператор пересечения:
###### **Замороженные множества**
a = frozenset([1, 2, 3]) - создание замороженного (неизменяемого) множества